package pyj.hadoop;

import java.io.IOException;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.util.GenericOptionsParser;

////////////// Mapper Input /////////////
/*		
year:2003 journal_no:1          The genome-wide transcriptome of the  P. falciparum  IDC was generated by measuring relative mRNA abundance levels in samples collected from a highly synchronized in vitro culture of parasites. The strain used was the well-characterized Honduran chloroquine-sensitive HB3 strain, which was used in the only two experimental crosses carried out thus far with  P. falciparum  ( Walliker et al. 1987 ;  Wellems et al. 1990 ). To obtain sufficient quantities of parasitized RBCs and to ensure the homogeneity of the samples, a large-scale culturing technique was developed using a 4.5 l bioreactor (see  Materials and Methods ). Samples were collected for a 48-h period beginning 1 h postinvasion (hpi). Culture synchronization was monitored every hour by Giemsa staining. We observed only the asexual form of the parasite in these stains. The culture was synchronous, with greater than 80% of the parasites invading fresh RBCs within 2 h prior to the harvesting of the first timepoint. Maintenance of synchrony throughout the IDC was demonstrated by sharp transitions between the ring-to-trophozoite and trophozoite-to-schizont stages at the 17- and 29-h timepoints, respectively ( Figure 1 A). 
year:2003 journal_no:1          The DNA microarray used in this study consists of 7,462 individual 70mer oligonucleotides representing 4,488 of the 5,409 ORFs manually annotated by the malaria genome sequencing consortium ( Bozdech et al. 2003 ). Of the 4,488 ORFs, 990 are represented by more than one oligonucleotide. Since our oligonucleotide design was based on partially assembled sequences periodically released by the sequencing consortium over the past several years, our set includes additional features representing 1,315 putative ORFs not part of the manually annotated collection. In this group, 394 oligonucleotides are no longer represented in the current assembled sequence. These latter ORFs likely fall into the gaps present in the published assembly available through the  Plasmodium  genome resource  PlasmoDB.org  ( Gardner et al. 2002 ;  Kissinger et al. 2002 ;  Bahl et al. 2003 ). 
year:2003 journal_no:1          To measure the relative abundance of mRNAs throughout the IDC, total RNA from each timepoint was compared to an arbitrary reference pool of total RNA from all timepoints in a standard two-color competitive hybridization ( Eisen and Brown 1999 ). The transcriptional profile of each ORF is represented by the mean-centered series of ratio measurements for the corresponding oligonucleotide(s) ( Figure 1 Bâ1E). Inspection of the entire dataset revealed a striking nonstochastic periodicity in the majority of expression profiles. The relative abundance of these mRNAs continuously varies throughout the IDC and is marked by a single maximum and a single minimum, as observed for the representative schizont-specific gene, erythrocyte-binding antigen 175 ( eba175 ), and the trophozoite-specific gene, dihydrofolate reductaseâthymidylate synthetase ( dhfr-ts ) ( Figure 1 B and 1C). However, there is diversity in both the absolute magnitude of relative expression and in the timing of maximal expression (phase). In addition, a minority of genes, such as adenylosuccinate lyase ( asl ) ( Figure 1 D), displayed a relatively constant expression profile. The accuracy of measurements from individual oligonucleotides was further verified by the ORFs that are represented by more than one oligonucleotide feature on the microarray. The calculated average pairwise Pearson correlation ( r ) is greater than 0.90 for 68% (0.75 for 86%) of the transcripts represented by multiple oligonucleotides with detectable expression during the IDC ( Table S1 ). Cases in which data from multiple oligonucleotides representing a single putative ORF disagree may represent incorrect annotation. The internal consistency of expression profile measurements for ORFs represented by more than one oligonucleotide sequence is graphically shown in  Figure 1 E for the hypothetical protein MAL6P1.147, the largest predicted ORF in the genome (31 kb), which is represented by 14 oligonucleotide elements spanning the entire length of the coding sequence. The average pairwise correlation ( r ) for these features is 0.98Â±0.02. 
year:2003 journal_no:1	         Periodicity in genome-wide.................
*/
////////////// Mapper Input /////////////         ----> 변수 <value>에 담겨온다.

public class NGramGenerator {
	/// 맵퍼///

	static int NGRAM_VALUE = 4; // 4그램까지 추출

	public static class NGramMapper extends Mapper<Object, Text, Text, IntWritable> {

		String journal_no = ""; // 처리중인 단어 논문번호
		String year = ""; // 파싱중인 단어 년도

		public void map(Object key, Text value, Context context) throws IOException, InterruptedException {

			String[] tokens = (value.toString().replace("\t", " ").toLowerCase()).split(" ");

			for (int i = 0; i < tokens.length; i++) {
				String token = tokens[i];

				if (token.contains("year:")) {
					year = token.substring(5); // 년도 추출
					continue;
				} else if (token.contains("journal_no:")) {
					journal_no = token.substring(11); // 논문번호 추출
					continue;
				}

				String ngram_set = "";

				for (int j = i - NGRAM_VALUE; j < i; j++) {
					if (i - NGRAM_VALUE < 0) {
						continue;
					}

					ngram_set += tokens[j] + " ";

					if (ngram_set.contains("http://")||ngram_set.contains("\n")) {
						ngram_set = "";
						continue;
					}

					int what_gram = ngram_set.split(" ").length;
					Text word = new Text();
					word.set(what_gram + ")\t" + year + "\t" + ngram_set + "\t" + journal_no);
					IntWritable one = new IntWritable(1);
					context.write(word, one);
				}

			}
		}
	}

	///// 컴바이너/////
	
	public static class NGramCombiner extends Reducer<Text, IntWritable, Text, IntWritable> {
		private IntWritable result = new IntWritable();

		public void reduce(Text key, Iterable<IntWritable> values, Context context)
				throws IOException, InterruptedException {
			int sum = 0;
			for (IntWritable val : values) {
				sum += val.get(); // 컴바이너에서 중간에 똑같은걸 더해주는 역핼만함.
			}
			result.set(sum);
			context.write(key, result);
		}
	}

	//input//
	
	// 1) 2005 apple 4 1
	// 4) 2005 apple dog dug pizza 5 2
	// 그램수) 년도   단어셋   저널넘버   빈도수
	
	/////// 리듀서   //////

	public static class NGramReducer extends Reducer<Text, IntWritable, Text, IntWritable> {
		private IntWritable result = new IntWritable();
		String[] before_input = { "", "", "","" }; // 이전 입력
		String[] current_input = { "", "", "","" }; // 현재입력
		int start = 0;
		int year_count = 0;
		int vol_count = 1;

		public void reduce(Text key, Iterable<IntWritable> values, Context context)
				throws IOException, InterruptedException {
			current_input = key.toString().split("\t");
			int value = 0;
			for (IntWritable val : values) {
				value += val.get();
			} // value값을 받아온것일뿐.
			current_input[3] = Integer.toString(value);
			
			if ((current_input[1] + current_input[2]).equals(current_input[1] + before_input[2])) {
				year_count = year_count + value;
				vol_count++;
			} // 정렬되어있으므로 현재키와 이전키가 같으면 계속 카운터를 더 해간다.

			else if (start != 0) {
				key = new Text(before_input[1] + "\t" + before_input[2] + "\t" + year_count);
				result.set(vol_count);
				context.write(key, result);
				year_count = 0;
				vol_count = 1;
				year_count = year_count + value;
			} else {
				year_count = year_count + value;
			}

			before_input = current_input;

			start++;

		}
	}

	public static void main(String[] args) throws Exception {
		Configuration conf = new Configuration();
		String[] otherArgs = new GenericOptionsParser(conf, args).getRemainingArgs();
		if (otherArgs.length != 2) {
			System.err.println("Usage: wordcount <in> <out>");
			System.exit(2);
		}
		Job job = new Job(conf, "word count");
		job.setJarByClass(NGramGenerator.class);
		// job.setNumReduceTasks(20); // 2 reducers
		job.setMapperClass(NGramMapper.class);
		job.setCombinerClass(NGramCombiner.class);
		job.setReducerClass(NGramReducer.class);
//		job.setReducerClass(NGramCombiner.class);
		job.setOutputKeyClass(Text.class);
		job.setOutputValueClass(IntWritable.class);
		FileInputFormat.addInputPath(job, new Path(otherArgs[0]));
		FileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));
		System.exit(job.waitForCompletion(true) ? 0 : 1);
	}
}
